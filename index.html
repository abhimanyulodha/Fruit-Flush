<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fruit Flush</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Pacifico&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #FFF5F5;
            --card: #FFFFFF;
            --text: #333333;
            --text-secondary: #8A93A2;
            --accent: #FF6B6B;
            --accent-light: #FFE4E1;
            --fruit-red: #FF6B6B;
            --fruit-yellow: #FFD700;
            --fruit-green: #5AC8FA;
            --fruit-orange: #FF9500;
            --fruit-pink: #FF2D55;
            --fruit-teal: #88D8C0;
            --fruit-purple: #AF52DE;
            --diagonal-highlight: #FFE6CC;
            --stuck-block: #FFB3B3;
        }
        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            overflow-y: auto;
            -webkit-font-smoothing: antialiased;
        }
        .rounded-card {
            border-radius: 14px;
            background-color: var(--card);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        .fruit-text {
            font-weight: 600;
            color: var(--text);
        }
        .fruit-accent {
            color: var(--accent);
        }
        .fruit-button {
            font-weight: 600;
            border-radius: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: none;
        }
        .fruit-button:active {
            transform: scale(0.98);
        }
        .fruit-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }
        .fruit-shadow {
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        /* Enhanced glassmorphism with better browser support */
        .glass-card {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 
                        0 0 0 1px rgba(255, 255, 255, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border: none !important;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .glass-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.18), 
                        0 0 0 1px rgba(255, 255, 255, 0.15),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        
        .glass-card-prominent {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15), 
                        0 0 0 1px rgba(255, 255, 255, 0.15),
                        inset 0 1px 0 rgba(255, 255, 255, 0.25);
            border: none !important;
        }
        .fruit-highlight {
            background-color: var(--accent-light);
        }
        .fruit-grid {
            display: grid;
            gap: 4px;
        }
        .fruit-cell {
            aspect-ratio: 1;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            transition: all 0.15s ease;
            background-color: rgba(255, 255, 255, 0.8);
        }
        .fruit-cell:hover {
            background-color: rgba(255, 230, 180, 0.7);
        }
        .fruit-score {
            font-weight: 600;
            color: var(--text-secondary);
        }
        .fruit-modal {
            border-radius: 16px;
            background-color: var(--card);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        }
        .fruit-confetti {
            position: fixed;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
        }
        @keyframes pop-in {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }
        .pop-in {
            animation: pop-in 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        @keyframes dice-tumble {
            0%   { transform: rotate(0deg) scale(1); }
            20%  { transform: rotate(-90deg) scale(1.05); }
            40%  { transform: rotate(-180deg) scale(1); }
            60%  { transform: rotate(-270deg) scale(1.05); }
            100% { transform: rotate(-360deg) scale(1); }
        }
        .dice-tumble {
            animation: dice-tumble 0.5s ease-in-out;
        }
        @keyframes score-flash {
            0% { color: var(--accent); }
            50% { color: var(--fruit-green); }
            100% { color: var(--accent); }
        }
        .score-flash {
            animation: score-flash 0.5s ease-out;
        }
        @keyframes roll-up {
            0% { transform: translateY(10px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        .score-roll-up {
            animation: roll-up 0.3s ease-out;
        }
        .modal {
            transition: opacity 0.25s ease, visibility 0.25s ease;
        }
        .modal-content {
            transition: transform 0.25s ease;
        }
        .modal.is-open {
            opacity: 1;
            visibility: visible;
        }
        .modal.is-open .modal-content {
            transform: scale(1) translateY(0);
        }
        @keyframes invalid-move-shake {
            10%, 90% { transform: translateX(-2px); }
            20%, 80% { transform: translateX(2px); }
            30%, 50%, 70% { transform: translateX(-3px); }
            40%, 60% { transform: translateX(3px); }
        }
        .invalid-move-shake {
            animation: invalid-move-shake 0.3s ease;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }
        #roll-dice-btn:not(:disabled) {
            animation: pulse 1.5s infinite;
        }
        .diagonal-cell {
            background-color: var(--diagonal-highlight) !important;
        }
        .stuck-cell {
            background-color: var(--stuck-block) !important;
            color: black;
            font-size: 2rem;
        }
        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
        .confetti-particle {
            animation: confetti-fall var(--duration, 3s) var(--delay, 0s) ease-out forwards;
        }
        /* Ensure equal heights for both panels */
        .game-container {
            display: flex;
            align-items: stretch;
        }
        .game-board-container,
        .scoring-panel-container {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <audio id="audio-unlocker" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" preload="auto"></audio>
    
    <!-- Centered Title -->
    <div class="fixed top-8 left-1/2 transform -translate-x-1/2 z-10">
        <h1 class="text-5xl font-bold text-center" style="font-family: 'Pacifico', cursive; color: #FF6B6B;">Fruit Flush</h1>
    </div>

    <main id="game-container" class="w-full max-w-5xl mx-auto game-container flex-col lg:flex-row gap-6 items-stretch p-4 pt-24">
        <div class="w-full lg:w-2/3 game-board-container">
            <div class="flex-1 p-4 rounded-card fruit-shadow">
                <div class="grid grid-cols-8 gap-2 h-full">
                    <div id="game-board" class="col-span-7 fruit-grid grid-cols-7 gap-2"></div>
                    <div id="row-scores-display" class="col-span-1 fruit-grid grid-rows-7 gap-2"></div>
                    <div id="col-scores-display" class="col-span-7 fruit-grid grid-cols-7 gap-2 mt-2"></div>
                </div>
            </div>
        </div>
        
        <div class="w-full lg:w-1/3 scoring-panel-container">
            <div class="flex-1 flex flex-col gap-3 p-4 bg-white/10 glass-card rounded-2xl">
                <!-- Header Section with Rules -->
                <div class="flex justify-between items-center">
                    <div class="flex gap-4">
                        <div class="text-center">
                            <h2 class="text-sm font-semibold uppercase tracking-wide" style="color: #FF6B6B;">High Score</h2>
                            <p id="high-score" class="text-2xl font-bold" style="color: #FFD700;">0</p>
                        </div>
                        <div class="text-center">
                            <h2 class="text-sm font-semibold uppercase tracking-wide" style="color: #FF6B6B;">Turn</h2>
                            <p id="turn-counter" class="text-2xl font-bold" style="color: #FF6B6B;">0/24</p>
                        </div>
                    </div>
                    <button id="help-btn" class="px-3 py-1.5 fruit-button rounded-lg text-sm font-semibold" style="color: #FF6B6B; background-color: #FFE4E1;">Rules</button>
                </div>
                
                <!-- Controls Area (Fixed Height) -->
                <div id="controls-area" class="py-4 min-h-[140px] flex items-center px-3">
                </div>
                
                <!-- Main Score Section -->
                <div class="text-center bg-gradient-to-br from-[#FFE4E1] to-[#FFF0F0] rounded-lg p-4">
                    <h2 class="text-sm font-semibold uppercase tracking-wide mb-1" style="color: #FF6B6B;">Total Score</h2>
                    <p id="total-score" class="text-4xl font-bold" style="color: #FF6B6B;">0</p>
                </div>
                
                <!-- Score Breakdown Grid -->
                <div class="grid grid-cols-2 gap-2 text-center">
                    <div class="bg-gray-50 rounded-lg p-2 border border-[#FFE4E1]">
                        <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: #FF6B6B;">Rows</h3>
                        <p id="rows-total-score" class="text-lg font-bold" style="color: #FF6B6B;">0</p>
                    </div>
                    <div class="bg-gray-50 rounded-lg p-2 border border-[#FFE4E1]">
                        <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: #FF6B6B;">Columns</h3>
                        <p id="cols-total-score" class="text-lg font-bold" style="color: #FF6B6B;">0</p>
                    </div>
                    <div class="bg-gradient-to-br from-[#FFD700]/20 to-[#FFD700]/10 rounded-lg p-2 border border-[#FFD700]/30">
                        <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: #FF6B6B;">Diagonal</h3>
                        <p id="diag-total-score" class="text-lg font-bold" style="color: #FFD700;">0</p>
                    </div>
                    <div class="bg-gradient-to-br from-[#FFD700]/20 to-[#FFD700]/10 rounded-lg p-2 border border-[#FFD700]/30">
                        <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: #FF6B6B;">Bonus Grid</h3>
                        <p id="bonus-grid-score" class="text-lg font-bold" style="color: #FFD700;">0</p>
                    </div>
                </div>
                
                <!-- Penalty Section -->
                <div class="bg-gradient-to-br from-[#FF6B6B]/10 to-[#FF6B6B]/5 rounded-lg p-2 border border-[#FF6B6B]/20">
                    <div class="text-center">
                        <h3 class="text-xs font-semibold uppercase tracking-wide" style="color: #FF6B6B;">Empty Block Penalty</h3>
                        <p id="empty-block-penalty" class="text-lg font-bold" style="color: #FF6B6B;">0</p>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <!-- Help Modal -->
    <div id="help-modal" class="modal fixed inset-0 bg-black/50 flex items-center justify-center p-4 opacity-0 invisible z-50">
        <div class="modal-content w-full max-w-lg bg-white p-6 rounded-xl transform scale-95 -translate-y-4" style="border: 2px solid #FF6B6B;">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-3xl font-bold" style="font-family: 'Pacifico', cursive; color: #FF6B6B;">How to Play Fruit Flush</h2>
                <button id="close-help-btn" class="w-8 h-8 rounded-full text-lg transition hover:bg-[#FFE4E1] flex items-center justify-center">×</button>
            </div>
            <div class="space-y-4 text-gray-700 text-sm max-h-[70vh] overflow-y-auto pr-2">
                <div>
                    <h3 class="font-bold text-lg mb-2" style="color: #FF6B6B;">The Objective</h3>
                    <p class="text-gray-800">The goal is to get the highest score possible by strategically placing fruit symbols on the grid to create sequences of 3 or more identical symbols in a line.</p>
                </div>
                <div>
                    <h3 class="font-bold text-lg mb-2" style="color: #FF6B6B;">Gameplay Flow</h3>
                    <ol class="list-decimal list-inside space-y-2 pl-4 text-gray-800">
                        <li><strong>Start the Game:</strong> First, choose a fruit symbol from the available options to place in the highlighted top-left corner of the grid.</li>
                        <li><strong>Take Your Turn:</strong> Click the "Roll Dice" button. You will be given two random fruit symbols to place on the board.</li>
                        <li><strong>Place Your Symbols:</strong> You must place both symbols on the board in empty squares that are adjacent to each other (either horizontally or vertically). <br><em class="text-xs">Tip: If you misclick on your first placement, simply click the same cell again to undo it.</em></li>
                    </ol>
                </div>
                <div>
                    <h3 class="font-bold text-lg mb-2" style="color: #FF6B6B;">Scoring System</h3>
                    <p class="mb-2 text-gray-800">Points are awarded for any horizontal or vertical line of three or more identical, adjacent symbols:</p>
                    <ul class="list-disc list-inside space-y-1 pl-4 text-gray-800">
                        <li><strong>3 Symbols</strong> in a line = 3 points</li>
                        <li><strong>4 Symbols</strong> in a line = 8 points</li>
                        <li><strong>5 Symbols</strong> in a line = 10 points</li>
                        <li><strong>6 Symbols</strong> in a line = 14 points</li>
                        <li><strong>7 Symbols</strong> in a line = 20 points</li>
                    </ul>
                    <p class="mt-3 p-3 bg-[#FFD700]/30 rounded-lg border border-[#FFD700]/50 text-gray-800">
                        <strong class="text-[#FF6B6B]">Diagonal Bonus:</strong> The score for any sequence on the specially colored diagonal line is <em>doubled!</em> This is key to a high score.
                    </p>
                    <div>
                        <h3 class="font-bold text-lg mb-2" style="color: #FF6B6B;">Bonus Grid</h3>
                        <p class="mb-2 text-gray-800">Points are awarded for creating grids of the same symbol:</p>
                        <ul class="list-disc list-inside space-y-1 pl-4 text-gray-800">
                            <li><strong>2x2 Grid</strong> = 4 points</li>
                            <li><strong>3x3 Grid</strong> = 9 points</li>
                            <li><strong>4x4 Grid</strong> = 16 points</li>
                            <li><strong>5x5 Grid</strong> = 25 points</li>
                            <li><strong>6x6 Grid</strong> = 36 points</li>
                            <li><strong>7x7 Grid</strong> = 49 points</li>
                        </ul>
                    </div>
                    <p class="mt-3 p-3 bg-[#FF6B6B]/30 rounded-lg border border-[#FF6B6B]/50 text-gray-800">
                        <strong class="text-[#FF6B6B]">Empty Block Penalty:</strong> Any empty block that is completely surrounded by filled cells and cannot be filled will incur a <strong>-1 point penalty</strong>. These blocks are highlighted with a red background and a 💣 symbol.
                    </p>
                    <p class="mt-3 p-3 bg-[#FF6B6B]/30 rounded-lg border border-[#FF6B6B]/50 text-gray-800">
                        <strong class="text-[#FF6B6B]">Penalty:</strong> Be careful! Any row or column where it's <strong>no longer possible</strong> to form a 3-symbol sequence will receive a <strong>-5 point penalty</strong>.
                    </p>
                </div>
                <div>
                    <h3 class="font-bold text-lg mb-2" style="color: #FF6B6B;">End of the Game</h3>
                    <p class="text-gray-800">The game ends when the entire grid is filled with symbols, or when there are no more valid moves left. Your final score is the sum of all your row scores, column scores, diagonal scores, bonus grid points, and empty block penalties.</p>
                </div>
            </div>
        </div>
    </div>
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal fixed inset-0 bg-black/50 flex items-center justify-center p-4 opacity-0 invisible z-50">
        <div class="modal-content w-full max-w-md text-center bg-white p-8 rounded-xl transform scale-95 -translate-y-4 relative" style="border: 2px solid #FF6B6B;">
            <button id="close-game-over-btn" class="absolute top-4 right-4 w-8 h-8 rounded-full text-lg transition hover:bg-[#FFE4E1] flex items-center justify-center">×</button>
            <h2 class="text-4xl font-bold" style="color: #FF6B6B; font-family: 'Pacifico', cursive;">Game Over!</h2>
            <p id="game-over-reason" class="text-lg mt-2" style="color: #FF6B6B;"></p>
            <p class="mt-4" style="color: #FF6B6B;">Your final score is:</p>
            <p id="final-score-modal" class="text-7xl font-bold my-4" style="color: #FF6B6B;">0</p>
            <p style="color: #FF6B6B;">Your high score: <span id="high-score-modal" class="font-bold" style="color: #FFD700;">0</span></p>
            <button id="play-again-btn" class="w-full mt-6 bg-[#FF6B6B] text-white font-bold py-3 px-4 rounded-lg text-xl transition-all hover:bg-[#FF5252]">Play Again</button>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Constants
            const FRUIT_SYMBOLS = {
                'Strawberry': '🍓',
                'Lemon': '🍋',
                'Kiwi': '🥝',
                'Cherry': '🍒',
                'Watermelon': '🍉',
                'Mango': '🥭'
            };
            const SYMBOLS = Object.values(FRUIT_SYMBOLS);
            const SYMBOL_COLORS = {
                '🍓': 'text-[#FF2D55]',
                '🍋': 'text-[#FFCC00]',
                '🥝': 'text-[#5AC8FA]',
                '🍒': 'text-[#FF3B30]',
                '🍉': 'text-[#88D8C0]',
                '🥭': 'text-[#FF9500]'
            };
            const SCORING_RULES = { 7: 20, 6: 14, 5: 10, 4: 8, 3: 3 };
            const GRID_SIZE = 7;
            const MAX_TURNS = 24;
            const DIAGONAL_MULTIPLIER = 2;
            const LINE_DEATH_PENALTY = -5;
            const STUCK_BLOCK_PENALTY = -1;
            const MIN_SEQUENCE_LENGTH = 3;
            const MAX_SEQUENCE_LENGTH = 7;
            const CONFETTI_COUNT = 50;
            const CONFETTI_DURATION = 2000;
            const DICE_ANIMATION_DURATION = 500;
            const SCORE_FLASH_DURATION = 500;

            // Game state
            let gameState, gridData, currentRoll, firstPlacementCell, turnCount, audioUnlocked, highScore, stuckBlocks;
            let scoreCache = new Map();
            let confettiPool = [];

            // DOM elements
            const DOMElements = {
                gameBoard: document.getElementById('game-board'),
                controlsArea: document.getElementById('controls-area'),
                rowScoresDisplay: document.getElementById('row-scores-display'),
                colScoresDisplay: document.getElementById('col-scores-display'),
                totalScore: document.getElementById('total-score'),
                highScore: document.getElementById('high-score'),
                rowsTotalScore: document.getElementById('rows-total-score'),
                colsTotalScore: document.getElementById('cols-total-score'),
                diagTotalScore: document.getElementById('diag-total-score'),
                bonusGridScore: document.getElementById('bonus-grid-score'),
                emptyBlockPenalty: document.getElementById('empty-block-penalty'),
                turnCounter: document.getElementById('turn-counter'),
                helpBtn: document.getElementById('help-btn'),
                helpModal: document.getElementById('help-modal'),
                closeHelpBtn: document.getElementById('close-help-btn'),
                gameOverModal: document.getElementById('game-over-modal'),
                closeGameOverBtn: document.getElementById('close-game-over-btn'),
                finalScoreModal: document.getElementById('final-score-modal'),
                highScoreModal: document.getElementById('high-score-modal'),
                playAgainBtn: document.getElementById('play-again-btn')
            };

            // Audio system
            const audioSystem = {
                unlocked: false,
                sounds: new Map(),
                
                init() {
                    this.createSounds();
                },
                
                createSounds() {
                    // Create audio contexts for different game events using Web Audio API
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        
                        this.sounds.set('place', () => this.playTone(audioContext, 440, 0.1, 0.1));
                        this.sounds.set('roll', () => this.playTone(audioContext, 220, 0.2, 0.2));
                        this.sounds.set('combo-3', () => this.playTone(audioContext, 523, 0.3, 0.15));
                        this.sounds.set('combo-4', () => this.playTone(audioContext, 659, 0.4, 0.2));
                        this.sounds.set('combo-5', () => this.playTone(audioContext, 784, 0.5, 0.25));
                        this.sounds.set('combo-6', () => this.playTone(audioContext, 880, 0.6, 0.3));
                        this.sounds.set('combo-7', () => this.playTone(audioContext, 1047, 0.7, 0.35));
                    } catch (e) {
                        // Fallback if Web Audio API not available
                        this.sounds.clear();
                    }
                },
                
                playTone(audioContext, frequency, volume, duration) {
                    if (!this.unlocked) return;
                    try {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(volume * 0.1, audioContext.currentTime + 0.01);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + duration);
                    } catch (e) {
                        // Ignore audio errors
                    }
                },
                
                unlock() {
                    if (this.unlocked) return;
                    const audioUnlocker = document.getElementById('audio-unlocker');
                    if (audioUnlocker) {
                        audioUnlocker.play().then(() => {
                            this.unlocked = true;
                        }).catch(() => {});
                    }
                },
                
                play(soundName) {
                    const sound = this.sounds.get(soundName);
                    if (sound) sound();
                }
            };

            // Confetti system with object pooling
            const confettiSystem = {
                pool: [],
                colors: ['#FF6B6B', '#FFD700', '#5AC8FA', '#FF9500', '#FF2D55', '#88D8C0'],
                
                init() {
                    // Pre-create confetti elements for better performance
                    for (let i = 0; i < CONFETTI_COUNT; i++) {
                        const particle = document.createElement('div');
                        particle.className = 'fruit-confetti confetti-particle';
                        particle.style.display = 'none';
                        document.body.appendChild(particle);
                        this.pool.push(particle);
                    }
                },
                
                trigger() {
                    this.pool.forEach((particle, index) => {
                        const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                        const delay = Math.random() * 0.5;
                        const duration = 2 + Math.random();
                        
                        particle.style.left = Math.random() * 100 + 'vw';
                        particle.style.top = '-10px';
                        particle.style.backgroundColor = color;
                        particle.style.setProperty('--delay', delay + 's');
                        particle.style.setProperty('--duration', duration + 's');
                        particle.style.display = 'block';
                        
                        // Reset animation
                        particle.style.animation = 'none';
                        particle.offsetHeight; // Trigger reflow
                        particle.style.animation = null;
                        
                        // Hide particle after animation
                        setTimeout(() => {
                            particle.style.display = 'none';
                        }, (duration + delay) * 1000);
                    });
                },
                
                cleanup() {
                    this.pool.forEach(particle => {
                        particle.style.display = 'none';
                    });
                }
            };

            // Score calculation utilities with caching
            const scoreCalculator = {
                cache: new Map(),
                
                clearCache() {
                    this.cache.clear();
                },
                
                getCachedLineScore(lineKey) {
                    return this.cache.get(lineKey);
                },
                
                setCachedLineScore(lineKey, score) {
                    this.cache.set(lineKey, score);
                },
                
                calculateLineScore(line) {
                    const lineKey = line.join(',');
                    const cached = this.getCachedLineScore(lineKey);
                    if (cached !== undefined) return cached;
                    
                    const result = this.computeLineScore(line);
                    this.setCachedLineScore(lineKey, result);
                    return result;
                },
                
                computeLineScore(line) {
                    let score = 0;
                    let foundSequence = false;
                    let tempLine = [...line];
                    
                    // Check for sequences from longest to shortest
                    for (let len = MAX_SEQUENCE_LENGTH; len >= MIN_SEQUENCE_LENGTH; len--) {
                        for (let i = 0; i <= tempLine.length - len; i++) {
                            const slice = tempLine.slice(i, i + len);
                            if (slice[0] !== null && slice.every(s => s && s === slice[0])) {
                                score += SCORING_RULES[len];
                                foundSequence = true;
                                // Mark as processed
                                for (let j = 0; j < len; j++) {
                                    tempLine[i + j] = null;
                                }
                            }
                        }
                    }
                    
                    if (foundSequence) {
                        return { score: score };
                    } else if (this.isLineDead(line)) {
                        return { score: LINE_DEATH_PENALTY };
                    } else {
                        return { score: 0 };
                    }
                },
                
                isLineDead(line) {
                    for (let i = 0; i <= line.length - MIN_SEQUENCE_LENGTH; i++) {
                        const window = line.slice(i, i + MIN_SEQUENCE_LENGTH);
                        const symbolsInWindow = window.filter(s => s !== null);
                        const uniqueSymbols = new Set(symbolsInWindow);
                        if (uniqueSymbols.size <= 1) return false;
                    }
                    return true;
                },
                
                // Optimized bonus grid detection
                calculateBonusGrids(gridData) {
                    let bonusPoints = 0;
                    const processed = new Set();
                    
                    // Check from largest to smallest to prioritize larger grids
                    for (let size = MAX_SEQUENCE_LENGTH; size >= 2; size--) {
                        for (let r = 0; r <= GRID_SIZE - size; r++) {
                            for (let c = 0; c <= GRID_SIZE - size; c++) {
                                const key = `${r},${c},${size}`;
                                if (processed.has(key)) continue;
                                
                                const symbol = gridData[r][c];
                                if (!symbol) continue;
                                
                                let isGrid = true;
                                for (let i = r; i < r + size && isGrid; i++) {
                                    for (let j = c; j < c + size && isGrid; j++) {
                                        if (gridData[i][j] !== symbol) {
                                            isGrid = false;
                                        }
                                    }
                                }
                                
                                if (isGrid) {
                                    bonusPoints += size * size;
                                    // Mark overlapping smaller grids as processed
                                    for (let smallerSize = 2; smallerSize < size; smallerSize++) {
                                        for (let sr = r; sr <= r + size - smallerSize; sr++) {
                                            for (let sc = c; sc <= c + size - smallerSize; sc++) {
                                                processed.add(`${sr},${sc},${smallerSize}`);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return bonusPoints;
                }
            };

            // Game logic functions
            function initGame() {
                gameState = 'PRE_GAME';
                gridData = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
                currentRoll = [];
                firstPlacementCell = null;
                turnCount = 0;
                stuckBlocks = new Set();
                highScore = localStorage.getItem('fruitFlushHighScore') || 0;
                
                // Clear caches
                scoreCache.clear();
                scoreCalculator.clearCache();
                
                // Initialize systems
                audioSystem.init();
                confettiSystem.init();
                
                DOMElements.highScore.textContent = highScore;
                DOMElements.gameOverModal.classList.remove('is-open');
                
                renderGrid();
                renderScorePlaceholders();
                renderControls();
                updateScoreDisplays(0, 0, 0, 0, 0);
                DOMElements.turnCounter.textContent = `0/${MAX_TURNS}`;
            }

            function renderGrid() {
                DOMElements.gameBoard.innerHTML = '';
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        let baseClasses = 'fruit-cell bg-[#FFF0F0] fruit-shadow';
                        
                        if (r + c === GRID_SIZE - 1) baseClasses += ' diagonal-cell';
                        if (r === 0 && c === 0 && gameState === 'PRE_GAME') baseClasses += ' border-2 border-[#FF6B6B]';
                        if (stuckBlocks.has(`${r},${c}`)) baseClasses += ' stuck-cell';
                        
                        cell.className = baseClasses;
                        
                        const symbol = gridData[r][c];
                        if (symbol) {
                            cell.textContent = symbol;
                            cell.classList.add(SYMBOL_COLORS[symbol], 'pop-in');
                        } else if (stuckBlocks.has(`${r},${c}`)) {
                            cell.textContent = '💣';
                        }
                        
                        DOMElements.gameBoard.appendChild(cell);
                    }
                }
            }

            function renderScorePlaceholders() {
                DOMElements.rowScoresDisplay.innerHTML = '';
                DOMElements.colScoresDisplay.innerHTML = '';
                for (let i = 0; i < GRID_SIZE; i++) {
                    DOMElements.rowScoresDisplay.innerHTML += `<div id="row-score-${i}" class="fruit-cell bg-[#FFF0F0] fruit-score">0</div>`;
                    DOMElements.colScoresDisplay.innerHTML += `<div id="col-score-${i}" class="fruit-cell bg-[#FFF0F0] fruit-score">0</div>`;
                }
            }

            function renderControls() {
                DOMElements.controlsArea.innerHTML = '';
                
                if (gameState === 'PRE_GAME') {
                    renderPreGameControls();
                } else {
                    renderGameControls();
                }
            }

            function renderPreGameControls() {
                const container = document.createElement('div');
                container.className = 'w-full flex flex-col justify-center';
                
                const title = document.createElement('h2');
                title.className = 'text-sm font-medium text-center mb-3 uppercase tracking-wide';
                title.style.color = '#FF6B6B';
                title.textContent = 'Choose Your Fruit';
                container.appendChild(title);
                
                const selector = document.createElement('div');
                selector.className = 'grid grid-cols-6 gap-1.5';
                SYMBOLS.forEach(symbol => {
                    const btn = document.createElement('button');
                    btn.className = `aspect-square rounded-md text-3xl hover:bg-[#FFE4E1] transition-colors ${SYMBOL_COLORS[symbol]} flex items-center justify-center`;
                    btn.textContent = symbol;
                    btn.onclick = () => handleSymbolSelect(symbol);
                    selector.appendChild(btn);
                });
                container.appendChild(selector);
                DOMElements.controlsArea.appendChild(container);
            }

            function renderGameControls() {
                const wrapper = document.createElement('div');
                wrapper.className = 'w-full flex flex-col justify-center';
                
                const diceContainer = document.createElement('div');
                diceContainer.className = 'text-center mb-3';
                
                const title = document.createElement('h2');
                title.className = 'text-sm font-medium uppercase tracking-wide mb-2';
                title.style.color = '#FF6B6B';
                title.textContent = 'Your Roll';
                diceContainer.appendChild(title);
                
                const diceFlex = document.createElement('div');
                diceFlex.className = 'flex justify-center gap-3 mb-3';
                diceFlex.innerHTML = `
                    <div id="dice-1" class="w-16 h-16 rounded-xl bg-white/50 backdrop-blur-sm shadow-lg flex items-center justify-center text-4xl">?</div>
                    <div id="dice-2" class="w-16 h-16 rounded-xl bg-white/50 backdrop-blur-sm shadow-lg flex items-center justify-center text-4xl">?</div>`;
                diceContainer.appendChild(diceFlex);
                
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex gap-3';
                
                const rollBtn = document.createElement('button');
                rollBtn.id = 'roll-dice-btn';
                rollBtn.className = 'flex-1 py-3 px-4 bg-[#FF6B6B]/80 glass-card text-white font-semibold rounded-2xl text-sm disabled:bg-[#FFB3B3]/60 disabled:cursor-not-allowed';
                rollBtn.textContent = 'Roll Dice';
                rollBtn.onclick = handleRollDice;
                
                const newGameBtn = document.createElement('button');
                newGameBtn.id = 'new-game-btn';
                newGameBtn.className = 'flex-1 py-3 px-4 bg-white/15 glass-card text-[#FF6B6B] font-semibold rounded-2xl text-sm';
                newGameBtn.textContent = 'New Game';
                newGameBtn.onclick = initGame;
                
                buttonContainer.appendChild(rollBtn);
                buttonContainer.appendChild(newGameBtn);
                wrapper.appendChild(diceContainer);
                wrapper.appendChild(buttonContainer);
                DOMElements.controlsArea.appendChild(wrapper);
                
                updateControlsState();
            }

            function updateControlsState() {
                if (gameState === 'PRE_GAME') return;
                
                const rollBtn = document.getElementById('roll-dice-btn');
                if (rollBtn) rollBtn.disabled = gameState !== 'AWAITING_ROLL';
                
                const dice1 = document.getElementById('dice-1');
                const dice2 = document.getElementById('dice-2');
                if (!dice1 || !dice2) return;
                
                if (gameState === 'AWAITING_PLACEMENT') {
                    updateDiceDisplay(dice1, dice2);
                } else {
                    resetDiceDisplay(dice1, dice2);
                }
            }

            function updateDiceDisplay(dice1, dice2) {
                dice1.textContent = currentRoll[0];
                dice1.className = `w-16 h-16 rounded-xl bg-white/80 backdrop-blur-sm shadow-lg flex items-center justify-center text-4xl ${SYMBOL_COLORS[currentRoll[0]]}`;
                dice2.textContent = currentRoll[1];
                dice2.className = `w-16 h-16 rounded-xl bg-white/80 backdrop-blur-sm shadow-lg flex items-center justify-center text-4xl ${SYMBOL_COLORS[currentRoll[1]]}`;
            }

            function resetDiceDisplay(dice1, dice2) {
                dice1.textContent = '?';
                dice1.className = 'w-16 h-16 rounded-xl bg-white/50 backdrop-blur-sm shadow-lg flex items-center justify-center text-4xl fruit-text';
                dice2.textContent = '?';
                dice2.className = 'w-16 h-16 rounded-xl bg-white/50 backdrop-blur-sm shadow-lg flex items-center justify-center text-4xl fruit-text';
            }

            function handleSymbolSelect(symbol) {
                if (gameState !== 'PRE_GAME') return;
                
                audioSystem.unlock();
                gridData[0][0] = symbol;
                gameState = 'AWAITING_ROLL';
                renderGrid();
                renderControls();
            }

            function handleRollDice() {
                if (gameState !== 'AWAITING_ROLL') return;
                
                gameState = 'ANIMATING_ROLL';
                updateControlsState();
                audioSystem.play('roll');
                
                const dice1El = document.getElementById('dice-1');
                const dice2El = document.getElementById('dice-2');
                dice1El.classList.add('dice-tumble');
                dice2El.classList.add('dice-tumble');
                
                setTimeout(() => {
                    dice1El.classList.remove('dice-tumble');
                    dice2El.classList.remove('dice-tumble');
                    currentRoll = [
                        SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)], 
                        SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)]
                    ];
                    gameState = 'AWAITING_PLACEMENT';
                    updateControlsState();
                }, DICE_ANIMATION_DURATION);
            }

            function handleCellClick(e) {
                const cell = e.target.closest('[data-row]');
                if (gameState !== 'AWAITING_PLACEMENT' || !cell) return;
                
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                if (firstPlacementCell) {
                    handleSecondPlacement(row, col, cell);
                } else {
                    handleFirstPlacement(row, col, cell);
                }
            }

            function handleFirstPlacement(row, col, cell) {
                if (!gridData[row][col]) {
                    if (!hasValidNeighbor(row, col)) {
                        showInvalidMoveAnimation(cell);
                        return;
                    }
                    
                    gridData[row][col] = currentRoll[0];
                    firstPlacementCell = { r: row, c: col };
                    renderGrid();
                    highlightValidMoves(row, col);
                }
            }

            function handleSecondPlacement(row, col, cell) {
                const { r, c } = firstPlacementCell;
                
                if (r === row && c === col) {
                    // Undo first placement
                    gridData[r][c] = null;
                    firstPlacementCell = null;
                    clearHighlights();
                    renderGrid();
                    return;
                }
                
                const isAdjacent = Math.abs(r - row) + Math.abs(c - col) === 1;
                if (isAdjacent && !gridData[row][col]) {
                    completeMove(row, col);
                }
            }

            function completeMove(row, col) {
                const longestSequenceBefore = findLongestSequence(gridData);
                gridData[row][col] = currentRoll[1];
                firstPlacementCell = null;
                turnCount++;
                DOMElements.turnCounter.textContent = `${turnCount}/${MAX_TURNS}`;
                clearHighlights();
                renderGrid();
                audioSystem.play('place');
                
                const longestSequenceAfter = findLongestSequence(gridData);
                if (longestSequenceAfter > longestSequenceBefore && longestSequenceAfter >= MIN_SEQUENCE_LENGTH) {
                    audioSystem.play(`combo-${longestSequenceAfter}`);
                    if (longestSequenceAfter >= 5) {
                        confettiSystem.trigger();
                    }
                }
                
                processTurnEnd();
            }

            function processTurnEnd() {
                detectStuckBlocks();
                calculateAllScores();
                
                const isGridFull = turnCount >= MAX_TURNS;
                if (isGridFull) {
                    endGame("The grid is full!");
                    return;
                }
                
                const noMovesLeft = !hasValidMoves(gridData);
                if (noMovesLeft) {
                    endGame("No more valid moves!");
                    return;
                }
                
                gameState = 'AWAITING_ROLL';
                renderControls();
            }

            function endGame(reason = "") {
                gameState = 'GAME_OVER';
                calculateAllScores();
                
                const finalScore = parseInt(DOMElements.totalScore.textContent);
                if (finalScore > highScore) {
                    highScore = finalScore;
                    localStorage.setItem('fruitFlushHighScore', highScore);
                    DOMElements.highScore.textContent = highScore;
                }
                
                document.getElementById('game-over-reason').textContent = reason;
                DOMElements.finalScoreModal.textContent = finalScore;
                DOMElements.highScoreModal.textContent = highScore;
                DOMElements.gameOverModal.classList.add('is-open');
            }

            function hasValidMoves(board) {
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (board[r][c] === null) {
                            if (c + 1 < GRID_SIZE && board[r][c + 1] === null) return true;
                            if (r + 1 < GRID_SIZE && board[r + 1][c] === null) return true;
                        }
                    }
                }
                return false;
            }

            function hasValidNeighbor(row, col) {
                const neighbors = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                return neighbors.some(([dr, dc]) => {
                    const r = row + dr;
                    const c = col + dc;
                    return r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE && !gridData[r][c];
                });
            }

            function showInvalidMoveAnimation(cell) {
                cell.classList.add('invalid-move-shake');
                setTimeout(() => cell.classList.remove('invalid-move-shake'), 300);
            }

            function findLongestSequence(board) {
                let maxLen = 0;
                
                const checkLine = (line) => {
                    if (line.length === 0) return 0;
                    let max = 0, current = 0, lastSymbol = null;
                    for (const symbol of line) {
                        if (symbol && symbol === lastSymbol) {
                            current++;
                        } else {
                            max = Math.max(max, current);
                            current = symbol ? 1 : 0;
                            lastSymbol = symbol;
                        }
                    }
                    return Math.max(max, current);
                };
                
                // Check rows
                for (let i = 0; i < GRID_SIZE; i++) {
                    maxLen = Math.max(maxLen, checkLine(board[i]));
                }
                
                // Check columns
                for (let i = 0; i < GRID_SIZE; i++) {
                    maxLen = Math.max(maxLen, checkLine(board.map(row => row[i])));
                }
                
                // Check diagonal
                maxLen = Math.max(maxLen, checkLine(Array.from({ length: GRID_SIZE }, (_, i) => board[i][GRID_SIZE - 1 - i])));
                
                return maxLen;
            }

            function detectStuckBlocks() {
                const neighbors = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (gridData[r][c] === null && !stuckBlocks.has(`${r},${c}`)) {
                            const isStuck = neighbors.every(([dr, dc]) => {
                                const nr = r + dr;
                                const nc = c + dc;
                                return nr < 0 || nr >= GRID_SIZE || nc < 0 || nc >= GRID_SIZE || gridData[nr][nc] !== null;
                            });
                            if (isStuck) {
                                stuckBlocks.add(`${r},${c}`);
                            }
                        }
                    }
                }
                DOMElements.emptyBlockPenalty.textContent = -stuckBlocks.size;
            }

            function calculateAllScores() {
                const scores = calculateRowScores();
                const colScores = calculateColumnScores();
                const diagScore = calculateDiagonalScore();
                const bonusGridScore = scoreCalculator.calculateBonusGrids(gridData);
                
                updateScoreDisplays(scores.total, colScores.total, diagScore, bonusGridScore, stuckBlocks.size);
                updateIndividualScores(scores.individual, colScores.individual);
            }

            function calculateRowScores() {
                let totalScore = 0;
                const individualScores = [];
                
                for (let i = 0; i < GRID_SIZE; i++) {
                    const { score } = scoreCalculator.calculateLineScore(gridData[i]);
                    individualScores.push(score);
                    totalScore += score;
                }
                
                return { total: totalScore, individual: individualScores };
            }

            function calculateColumnScores() {
                let totalScore = 0;
                const individualScores = [];
                
                for (let i = 0; i < GRID_SIZE; i++) {
                    const colLine = gridData.map(row => row[i]);
                    const { score } = scoreCalculator.calculateLineScore(colLine);
                    individualScores.push(score);
                    totalScore += score;
                }
                
                return { total: totalScore, individual: individualScores };
            }

            function calculateDiagonalScore() {
                const diagLine = Array.from({ length: GRID_SIZE }, (_, i) => gridData[i][GRID_SIZE - 1 - i]);
                const { score: diagBaseScore } = scoreCalculator.calculateLineScore(diagLine);
                return diagBaseScore * DIAGONAL_MULTIPLIER;
            }

            function updateScoreDisplays(rowsTotal, colsTotal, diagTotal, bonusTotal, stuckCount) {
                const totalScore = rowsTotal + colsTotal + diagTotal + bonusTotal - stuckCount;
                
                DOMElements.totalScore.textContent = totalScore;
                DOMElements.rowsTotalScore.textContent = rowsTotal;
                DOMElements.colsTotalScore.textContent = colsTotal;
                DOMElements.diagTotalScore.textContent = diagTotal;
                DOMElements.bonusGridScore.textContent = bonusTotal;
            }

            function updateIndividualScores(rowScores, colScores) {
                rowScores.forEach((score, i) => updateScoreElement(`row-score-${i}`, score));
                colScores.forEach((score, i) => updateScoreElement(`col-score-${i}`, score));
            }

            function updateScoreElement(id, score) {
                const el = document.getElementById(id);
                if (el && el.textContent != score) {
                    el.textContent = score;
                    el.classList.toggle('text-[#ff3b30]', score < 0);
                    el.classList.toggle('fruit-text', score >= 0);
                    if (score > 0) {
                        el.classList.add('score-flash');
                        setTimeout(() => el.classList.remove('score-flash'), SCORE_FLASH_DURATION);
                    }
                }
            }

            function highlightValidMoves(row, col) {
                [[-1, 0], [1, 0], [0, -1], [0, 1]].forEach(([dr, dc]) => {
                    const r = row + dr, c = col + dc;
                    const cell = DOMElements.gameBoard.querySelector(`[data-row='${r}'][data-col='${c}']`);
                    if (cell && !gridData[r][c]) {
                        cell.classList.add('fruit-highlight');
                    }
                });
            }

            function clearHighlights() {
                DOMElements.gameBoard.querySelectorAll('[data-row]').forEach(cell => {
                    cell.classList.remove('fruit-highlight');
                });
            }

            // Event listeners
            DOMElements.helpBtn.onclick = () => DOMElements.helpModal.classList.add('is-open');
            DOMElements.closeHelpBtn.onclick = () => DOMElements.helpModal.classList.remove('is-open');
            DOMElements.closeGameOverBtn.onclick = () => DOMElements.gameOverModal.classList.remove('is-open');
            DOMElements.playAgainBtn.onclick = initGame;
            DOMElements.gameBoard.onclick = handleCellClick;

            // Initialize game
            initGame();
        });
    </script>
</body>
</html>
